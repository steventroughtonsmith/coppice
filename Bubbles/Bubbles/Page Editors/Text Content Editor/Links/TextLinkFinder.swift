//
//  TextLinkFinder.swift
//  Bubbles
//
//  Created by Martin Pilkington on 06/12/2019.
//  Copyright Â© 2019 M Cubed Software. All rights reserved.
//

import Cocoa

class TextLinkFinder: NSObject {
    func findLinkChanges(in attributedString: NSAttributedString, using pages: [Page]) -> LinkChanges {
        let existingLinks = self.existingLinks(in: attributedString, pages: pages)
        let autoLinkPages = self.autoLinkCandidates(from: pages)
        var autoLinks = [LinkInfo]()
        for page in autoLinkPages {
            autoLinks.append(contentsOf: self.autoLinks(for: page, in: attributedString))
        }

        let links = self.combineAndSort(existingLinks: existingLinks, autoLinks: autoLinks)
        var linkToAdd = [Link]()
        var linkToRemove = [Link]()
        var index = 0
        while (index < links.count) {
            let scratchPad = self.createScratchPad(from: links, currentIndex: &index)
            self.validateManualLinks(in: scratchPad)
            self.validateAutoLinks(in: scratchPad)
            for linkInfo in scratchPad.links {
                //We want to add any valid new links
                if (linkInfo.age == .new) && (linkInfo.state == .accepted) {
                    let url = linkInfo.page?.linkToPage(autoGenerated: (linkInfo.linkType == .auto)).url
                    let link = Link(range: linkInfo.range, url: url)
                    linkToAdd.append(link)
                }
                //We want to remove any invalid existing links
                if (linkInfo.age == .existing) && (linkInfo.state == .rejected) {
                    let link = Link(range: linkInfo.range, url: nil)
                    linkToRemove.append(link)
                }
                //All other links can be discarded
            }
        }

        return LinkChanges(linksToRemove: linkToRemove, linksToAdd: linkToAdd)
    }

    private func existingLinks(in attributedString: NSAttributedString, pages: [Page]) -> [LinkInfo] {
        let pagesByID = pages.indexed(by: \.id)

        var links = [LinkInfo]()
        attributedString.enumerateAttribute(.link, in: attributedString.fullRange, options: []) { (value, range, _) in
            guard let value = value else {
                return
            }
            var page: Page? = nil
            var isAuto = false
            if let url = value as? URL, let link = PageLink(url: url) {
                page = pagesByID[link.destination]
                isAuto = link.autoGenerated
            }
            links.append(LinkInfo(range: range, page: page, linkType: (isAuto ? .auto : .manual), age: .existing))
        }
        return links
    }

    private func autoLinkCandidates(from pages: [Page]) -> [Page] {
        var autoLinkCandidates = [Page]()
        for page in pages {
            guard page.title != Page.localizedDefaultTitle else {
                continue
            }
            if let index = autoLinkCandidates.firstIndex(where: { $0.title == page.title }) {
                autoLinkCandidates.remove(at: index)
                continue
            }
            autoLinkCandidates.append(page)
        }
        return autoLinkCandidates
    }

    private func autoLinks(for page: Page, in attributedString: NSAttributedString) -> [LinkInfo] {
        let escapedTitle = NSRegularExpression.escapedPattern(for: page.title)
        guard let regex = try? NSRegularExpression(pattern: "((?<=\\W|_)|^)\(escapedTitle)((?=\\W|_)|$)", options: [.caseInsensitive]) else {
            return []
        }
        let matches = regex.matches(in: attributedString.string, options: [], range: attributedString.fullRange)
        return matches.map { LinkInfo(range: $0.range, page: page, linkType: .auto, age: .new) }
    }

    private func combineAndSort(existingLinks: [LinkInfo], autoLinks: [LinkInfo]) -> [LinkInfo] {
        let links = existingLinks + autoLinks
        return links.sorted { $0.range.location < $1.range.location }
    }

    private func createScratchPad(from links: [LinkInfo], currentIndex: inout Int) -> LinkScratchPad {
        var scratchPadLinks = [LinkInfo]()
        var currentRange: NSRange? = nil
        while currentIndex < links.count {
            let link = links[currentIndex]
            guard let range = currentRange else {
                currentRange = link.range
                scratchPadLinks.append(link)
                currentIndex += 1
                continue
            }

            guard link.range.intersection(range) != nil else {
                break
            }

            currentIndex += 1
            currentRange = range.union(link.range)
            scratchPadLinks.append(link)
        }
        return LinkScratchPad(links: scratchPadLinks)
    }

    //Rules
    private func validateManualLinks(in scratchPad: LinkScratchPad) {
        let manualLinks = scratchPad.links.filter { $0.linkType == .manual && $0.state != .rejected }
        let autoLinks = scratchPad.links.filter { $0.linkType == .auto }

        for link in autoLinks {
            for manualLink in manualLinks {
                if link.range.intersection(manualLink.range) != nil {
                    link.state = .rejected
                    break
                }
            }
        }
    }

    private func validateAutoLinks(in scratchPad: LinkScratchPad) {
        scratchPad.enumerateUnrejectedPoints { (links) in
            if links.count == 1 {
                if links[0].state == .unknown {
                    links[0].state = (links[0].age == .new) ? .accepted : .rejected
                }
            }
            else if links.filter({ $0.state == .accepted }).count > 0 {
                links.filter { $0.state != .accepted }.forEach { $0.state = .rejected }
            }
            //If we ever get to this part then we have multiple links, none of which have been accepted. This means they all start at the same location
            else {
                var currentLink: LinkInfo?
                for link in links {
                    guard let current = currentLink else {
                        currentLink = link
                        continue
                    }

                    if current.range.length > link.range.length {
                        link.state = .rejected
                    }
                    else if current.range.length < link.range.length {
                        current.state = .rejected
                        currentLink = link
                    }
                    else if current.range.length == link.range.length {
                        if link.age == .new {
                            link.state = .rejected
                        } else {
                            current.state = .rejected
                            currentLink = link
                        }
                    }
                }
                currentLink?.state = .accepted
            }
        }
    }


    struct LinkChanges {
        let linksToRemove: [Link]
        let linksToAdd: [Link]
    }

    struct Link: Equatable {
        let range: NSRange
        let url: URL?
    }
}


private class LinkInfo: Equatable {
    static func == (lhs: LinkInfo, rhs: LinkInfo) -> Bool {
        return lhs.age == rhs.age &&
            lhs.page == rhs.page &&
            lhs.linkType == rhs.linkType &&
            lhs.state == rhs.state &&
            lhs.age == rhs.age
    }

    enum State: Equatable {
        case unknown
        case accepted
        case rejected
    }

    enum Age: Equatable {
        case new
        case existing
    }

    enum LinkType: Equatable {
        case manual
        case auto
    }

    let range: NSRange
    let page: Page?
    let linkType: LinkType
    var state: State = .unknown
    var age: Age

    init(range: NSRange, page: Page?, linkType: LinkType, age: Age) {
        self.range = range
        self.page = page
        self.linkType = linkType
        self.age = age
        if page == nil {
            self.state = .rejected
        }
    }

    var description: String {
        return "LinkInfo: { range: \(self.range), page: \(self.page?.title ?? "nil"), linkType: \(self.linkType), age: \(self.age), state: \(self.state)}"
    }
}


private class LinkScratchPad {
    let links: [LinkInfo]
    private let unrejectedAutoLinksByPoint: [[LinkInfo]]
    init(links: [LinkInfo]) {
        self.links = links
        self.unrejectedAutoLinksByPoint = LinkScratchPad.groupAutoLinksByPoint(links: links)
    }

    private static func groupAutoLinksByPoint(links: [LinkInfo]) -> [[LinkInfo]] {
        guard links.count > 0 else {
            return []
        }
        var fullRange: NSRange!
        for link in links {
            guard let range = fullRange else {
                fullRange = link.range
                continue
            }
            fullRange = range.union(link.range)
        }

        var groupedLinks = Array(repeating: [LinkInfo](), count: fullRange.length)
        for link in links {
            guard link.linkType != .manual else {
                continue
            }
            let startIndex = link.range.location - fullRange.location
            let endIndex = NSMaxRange(link.range) - fullRange.location
            (startIndex..<endIndex).forEach { (index) in
                var group = groupedLinks[index]
                group.append(link)
                groupedLinks[index] = group
            }
        }

        var currentGroup: [LinkInfo]?
        var condensedGroupLinks = [[LinkInfo]]()
        for group in groupedLinks {
            guard let current = currentGroup else {
                condensedGroupLinks.append(group)
                currentGroup = group
                continue
            }
            guard group != current else {
                continue
            }
            condensedGroupLinks.append(group)
            currentGroup = group
        }
        return condensedGroupLinks
    }

    func enumerateUnrejectedPoints(_ block: ([LinkInfo]) -> Void) {
        self.unrejectedAutoLinksByPoint.forEach { linkInfo in
            block(linkInfo.filter { $0.state != .rejected } )
        }
    }
}
