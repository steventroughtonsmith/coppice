//
//  PlistV2.swift
//  CoppiceCore
//
//  Created by Martin Pilkington on 31/07/2022.
//

import Foundation
import M3Data

extension Plist {
    class V2: ModelPlist {
        override class var version: Int {
            return 2
        }

        override class var supportedTypes: [ModelPlist.PersistenceTypes] {
            return [
                PersistenceTypes(modelType: Page.modelType, persistenceName: "pages"),
                PersistenceTypes(modelType: Folder.modelType, persistenceName: "folders"),
                PersistenceTypes(modelType: Canvas.modelType, persistenceName: "canvases"),
                PersistenceTypes(modelType: CanvasPage.modelType, persistenceName: "canvasPages"),
            ]
        }

        override func migrateToNextVersion() throws -> [String: PlistValue] {
            var migratedPlist = [String: PlistValue]()

            migratedPlist["pages"] = self.plistRepresentations(of: Page.modelType).map(\.persistenceRepresentation) as any PlistValue
            migratedPlist["folders"] = self.plistRepresentations(of: Folder.modelType).map(\.persistenceRepresentation) as any PlistValue

            migratedPlist["settings"] = self.settings as any PlistValue
            migratedPlist["version"] = V3.version


            let existingCanvasPages = self.plistRepresentations(of: CanvasPage.modelType)
            var canvasPagesByID = [String: ModelObjectPlistRepresentation]()
            for existingCanvasPage in existingCanvasPages {
                guard let id: ModelID = try? existingCanvasPage[.id] else {
                    throw ModelPlist.Errors.missingID(existingCanvasPage.persistenceRepresentation)
                }
                canvasPagesByID[id.stringRepresentation] = existingCanvasPage
            }

            let existingCanvases = self.plistRepresentations(of: Canvas.modelType)
            let createdPageHierarchies = try migratePageHierarchies(canvases: existingCanvases, openCanvasPages: canvasPagesByID)

            migratedPlist["pageHierarchies"] = createdPageHierarchies.map(\.persistenceRepresentation) as any PlistValue
            migratedPlist["canvases"] = existingCanvases.map(\.persistenceRepresentation) as any PlistValue


            var createdCanvasLinks = [ModelObjectPlistRepresentation]()
            var migratedCanvasPages = [ModelObjectPlistRepresentation]()
            for canvasPage in existingCanvasPages {
                guard let destinationID: ModelID = try? canvasPage[.id] else {
                    throw ModelPlist.Errors.missingID(canvasPage.persistenceRepresentation)
                }

                guard let sourceID: String = try? canvasPage[ModelPlistKey(rawValue: "parent")] else {
                    migratedCanvasPages.append(canvasPage)
                    continue
                }

                guard
                    canvasPagesByID[sourceID] != nil,
                    let sourceCanvasPageID = ModelID(string: sourceID),
                    let destinationPageID: ModelID = try? canvasPage[CanvasPage.PlistKeys.page],
                    let canvas: ModelID = try? canvasPage[CanvasPage.PlistKeys.canvas]
                else {
                    throw ModelPlist.Errors.migrationFailed("Missing page for link between pages \(sourceID) and \(destinationID)")
                }


                var updatedCanvasPagePlist = canvasPage.plist
                updatedCanvasPagePlist[ModelPlistKey(rawValue: "parent")] = nil
                migratedCanvasPages.append(.init(id: canvasPage.id, plist: updatedCanvasPagePlist))

                let canvasLinkID = CanvasLink.modelID(with: UUID())
                let canvasLink: [ModelPlistKey: PlistValue] = [
                    .id: canvasLinkID.stringRepresentation,
                    CanvasLink.PlistKeys.link: PageLink(destination: destinationPageID, source: sourceCanvasPageID, autoGenerated: false).url.absoluteString,
                    CanvasLink.PlistKeys.sourcePage: sourceID,
                    CanvasLink.PlistKeys.destinationPage: destinationID.stringRepresentation,
                    CanvasLink.PlistKeys.canvas: canvas.stringRepresentation,
                ]
                createdCanvasLinks.append(ModelObjectPlistRepresentation(id: canvasLinkID, plist: canvasLink))
            }

            migratedPlist["canvasPages"] = migratedCanvasPages.map(\.persistenceRepresentation) as any PlistValue
            migratedPlist["canvasLinks"] = createdCanvasLinks.map(\.persistenceRepresentation) as any PlistValue

            return migratedPlist
        }


        fileprivate func migratePageHierarchies(canvases: [ModelObjectPlistRepresentation], openCanvasPages: [String: ModelObjectPlistRepresentation]) throws -> [ModelObjectPlistRepresentation] {
            struct HierarchyCanvasPage {
                var pageID: ModelID
                var frame: CGRect
            }

            var allOpenPages = [ModelID: HierarchyCanvasPage]()
            for (idString, canvasPage) in openCanvasPages {
                guard
                    let canvasPageID = ModelID(string: idString),
                    let pageID: ModelID = try canvasPage[CanvasPage.PlistKeys.page],
                    let frameString: String = try canvasPage[CanvasPage.PlistKeys.frame]
                else {
                    throw ModelPlist.Errors.migrationFailed("Invalid canvas page found")
                }
                allOpenPages[canvasPageID] = HierarchyCanvasPage(pageID: pageID, frame: NSRectFromString(frameString))
            }

            var createdPageHierarchies = [ModelObjectPlistRepresentation]()
            for canvas in canvases {
                guard let closedHierarchies = canvas.plist[ModelPlistKey(rawValue: "closedPageHierarchies")] as? [String: [String: [String: Any]]] else {
                    continue
                }

                guard let canvasID: ModelID = try canvas[.id] else {
                    throw ModelPlist.Errors.migrationFailed("Invalid canvas found")
                }

                //Loop through closed hierarchies
                //List of root canvas page IDs
                //List of root hierarchies
                //List of ALL pages (open and closed)

                var allPages = allOpenPages
                for (_, hierarchies) in closedHierarchies {
                    for (_, rawLegacyHierarchy) in hierarchies {
                        guard let legacyHierarchy = LegacyPageHierarchy(plistRepresentation: rawLegacyHierarchy) else {
                            throw ModelPlist.Errors.migrationFailed("Invalid page hierarchy found")
                        }

                        let (pages, _) = legacyHierarchy.flattenedHierarchyAndLinks()

                        for page in pages {
                            allPages[page.id] = HierarchyCanvasPage(pageID: page.pageID, frame: page.frame)
                        }
                    }
                }

                for (canvasPageID, hierarchies) in closedHierarchies {
                    guard
                        let canvasPageModelID = ModelID(string: canvasPageID),
                        let page = allPages[canvasPageModelID]
                    else {
                        continue
                    }
                    for (_, rawLegacyHierarchy) in hierarchies {
                        guard let legacyHierarchy = LegacyPageHierarchy(plistRepresentation: rawLegacyHierarchy) else {
                            throw ModelPlist.Errors.migrationFailed("Invalid page hierarchy found")
                        }

                        var pageHierarchyPlist = legacyHierarchy.pageHierarchyPersistenceRepresentation(withSourceCanvasPageID: canvasPageModelID, sourcePageID: page.pageID, andFrame: page.frame)
                        let id = ModelID(modelType: PageHierarchy.modelType)
                        pageHierarchyPlist[.id] = id.stringRepresentation
                        pageHierarchyPlist[PageHierarchy.PlistKeys.canvas] = canvasID.stringRepresentation
                        createdPageHierarchies.append(ModelObjectPlistRepresentation(id: id, plist: pageHierarchyPlist))
                    }
                }
            }
            return createdPageHierarchies
        }
    }
}
