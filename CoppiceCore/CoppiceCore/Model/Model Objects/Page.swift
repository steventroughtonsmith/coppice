//
//  Page.swift
//  Coppice
//
//  Created by Martin Pilkington on 15/07/2019.
//  Copyright Â© 2019 M Cubed Software. All rights reserved.
//

import Cocoa
import M3Data

struct Tag {
    let name: String
}

final public class Page: NSObject, CollectableModelObject, FolderContainable {
    public static let standardSize = CGSize(width: 300, height: 200)
    public static let defaultMinimumContentSize = CGSize(width: 150, height: 100)
    public static let contentChangedNotification = Notification.Name("PageContentChangedNotification")
    public static let localizedDefaultTitle = "Untitled Page"

    //MARK: - ModelObject Definitions
    public static let modelType: ModelType = ModelType(rawValue: "Page")!
    public var id = ModelID(modelType: Page.modelType)
    public weak var collection: ModelCollection<Page>?


    //MARK: - Init
    override public init() {
        self.title = ""
        self.content = TextPageContent()
        super.init()
        self.content.page = self
    }


    // MARK: - Attributes
    @objc dynamic public var title: String {
        didSet { self.didChange(\.title, oldValue: oldValue) }
    }

    @objc dynamic public var dateCreated = Date()
    @objc dynamic public var dateModified = Date()
    private var userPreferredSize: CGSize?
    public var contentSize: CGSize {
        get {
            return self.userPreferredSize ?? self.content.initialContentSize ?? Page.standardSize
        }
        set {
            self.userPreferredSize = newValue
        }
    }

    /// Added in 2021.2
    @objc dynamic public var allowsAutoLinking: Bool = true {
        didSet { self.didChange(\.allowsAutoLinking, oldValue: oldValue) }
    }

    public private(set) var otherProperties = [ModelPlistKey: Any]()


    //MARK: - Relationships
    public var canvasPages: Set<CanvasPage> {
        return self.relationship(for: \.page)
    }


    //MARK: - FolderContainable
    public weak var containingFolder: Folder? {
        didSet { self.didChange(\.containingFolder, oldValue: oldValue) }
    }

    public var sortType: String {
        let type = self.content.contentType
        let index = PageContentType.allCases.firstIndex(of: type) ?? -1
        return "\(index + 1)\(type.rawValue)"
    }


    // MARK: - Content
    public var content: PageContent {
        didSet {
            self.content.page = self
            NotificationCenter.default.post(name: Page.contentChangedNotification, object: self)
            self.didChange(\.content, oldValue: oldValue)
        }
    }

    func contentSizeDidChange(to newSize: CGSize, oldSize: CGSize?) {
        if let undoManager = self.undoManager {
            guard undoManager.isUndoing == false, undoManager.isRedoing == false else {
                return
            }
        }
        self.canvasPages.forEach { $0.contentSizeDidChange(to: newSize, oldSize: oldSize) }
    }


    //MARK: - Helpers
    public func updatePageSizes() {
        guard self.userPreferredSize == nil else {
            return
        }
        self.canvasPages.forEach { canvasPage in
            var frame = canvasPage.frame
            frame.size = self.contentSize
            canvasPage.frame = frame
        }
    }

    public func linkToPage(autoGenerated: Bool = false) -> PageLink {
        return PageLink(destinationPage: self, autoGenerated: autoGenerated)
    }



    //MARK: - Plists
    public static var propertyConversions: [ModelPlistKey: ModelPropertyConversion] {
        return [.Page.content: .modelFile]
    }

    public var plistRepresentation: [ModelPlistKey: Any] {
        var plist = self.otherProperties
        plist[.id] = self.id.stringRepresentation
        plist[.Page.title] = self.title
        plist[.Page.dateCreated] = self.dateCreated
        plist[.Page.dateModified] = self.dateModified
        plist[.Page.content] = self.content.modelFile
        if let preferredSize = self.userPreferredSize {
            plist[.Page.userPreferredSize] = NSStringFromSize(preferredSize)
        }
        plist[.Page.allowsAutoLinking] = self.allowsAutoLinking

        return plist
    }

    public func update(fromPlistRepresentation plist: [ModelPlistKey: Any]) throws {
        guard self.id == plist.attribute(withKey: .id) else {
            throw ModelObjectUpdateErrors.idsDontMatch
        }

        //Get values
        let title: String = try plist.requiredAttribute(withKey: .Page.title)
        let dateCreated: Date = try plist.requiredAttribute(withKey: .Page.dateCreated)
        let dateModified: Date = try plist.requiredAttribute(withKey: .Page.dateModified)

        var userPreferredSize: CGSize? = nil
        if let userPreferredSizeString: String = plist.attribute(withKey: .Page.userPreferredSize) {
            userPreferredSize = NSSizeFromString(userPreferredSizeString)
        }

        let contentModelFile: ModelFile = try plist.requiredAttribute(withKey: .Page.content)
        guard let contentType = PageContentType(rawValue: contentModelFile.type) else {
            throw ModelObjectUpdateErrors.attributeNotFound(ModelPlistKey.Page.content.rawValue)
        }

        let allowsAutoLinking = plist.attribute(withKey: .Page.allowsAutoLinking) ?? true

        //Set values
        self.title = title
        self.dateCreated = dateCreated
        self.dateModified = dateModified
        self.userPreferredSize = userPreferredSize
        self.content = try contentType.createContent(modelFile: contentModelFile)
        self.allowsAutoLinking = allowsAutoLinking

        let plistKeys = ModelPlistKey.Page.all
        self.otherProperties = plist.filter { (key, _) -> Bool in
            return plistKeys.contains(key) == false
        }
    }
}


extension ModelCollection where ModelType == Page {
    @discardableResult public func newPage(fromFileAt url: URL) -> Page? {
        guard
            let resourceValues = try? url.resourceValues(forKeys: Set([.typeIdentifierKey])),
            let typeIdentifier = resourceValues.typeIdentifier
        else {
                return nil
        }

        guard let contentType = PageContentType.contentType(forUTI: typeIdentifier) else {
            return nil
        }

        guard let data = try? Data(contentsOf: url) else {
            return nil
        }

        let page = self.newObject() {
            $0.title = (url.lastPathComponent as NSString).deletingPathExtension
            $0.content = contentType.createContent(data: data)
        }
        return page
    }

    public func setContentValue<Value, ContentType>(_ value: Value, for keyPath: ReferenceWritableKeyPath<ContentType, Value>, ofPageWithID id: ModelID) {
        guard
            let page = self.objectWithID(id),
            let content = page.content as? ContentType
        else {
            return
        }
        content[keyPath: keyPath] = value
    }
}


extension ModelPlistKey {
    enum Page {
        static let title = ModelPlistKey(rawValue: "title")
        static let dateCreated = ModelPlistKey(rawValue: "dateCreated")
        static let dateModified = ModelPlistKey(rawValue: "dateModified")
        static let content = ModelPlistKey(rawValue: "content")
        static let userPreferredSize = ModelPlistKey(rawValue: "userPreferredSize")
        static let allowsAutoLinking = ModelPlistKey(rawValue: "allowsAutoLinking") //Added 2021.2

        static var all: [ModelPlistKey] {
            return [.id, .Page.title, .Page.dateCreated, .Page.dateModified, .Page.content, .Page.userPreferredSize, .Page.allowsAutoLinking]
        }
    }
}
