//
//  ImageLinkFinder.swift
//  Coppice
//
//  Created by Martin Pilkington on 07/04/2022.
//  Copyright Â© 2022 M Cubed Software. All rights reserved.
//

import Cocoa
import CoppiceCore
import Vision

class ImageLinkFinder: LinkFinder {
    static func updateHotspots(_ hotspots: [ImageHotspot], for recognisedTexts: [VNRecognizedText], using pages: [Page], ignoring ignoredPages: [Page], imageSize: CGSize, orientation: CGImagePropertyOrientation) -> [ImageHotspot] {
        let manualHotspots = hotspots.filter { $0.isAutoHotspot == false }
        var autoHotspots = [ImageHotspot]()

        let autoLinkPages = self.autoLinkCandidates(from: pages, ignoring: ignoredPages)
        let manualHotspotRects = manualHotspots.compactMap { CGRect(points: $0.points) }
        for recognisedText in recognisedTexts {
            let hotspots = self.candidateHotspotsForPages(autoLinkPages, in: recognisedText, imageSize: imageSize, orientation: orientation).filter { hotspot in
                if let autoRect = CGRect(points: hotspot.points) {
                    for manualRect in manualHotspotRects {
                        if manualRect.intersects(autoRect) {
                            return false
                        }
                    }
                }
                return true
            }
            //Validate not overlapping with manual hotspots
            autoHotspots.append(contentsOf: hotspots)
        }


        return manualHotspots + autoHotspots
    }



    static func candidateHotspotsForPages(_ autoLinkPages: [Page], in recognisedText: VNRecognizedText, imageSize: CGSize, orientation: CGImagePropertyOrientation) -> [ImageHotspot] {
        var autoLinks = [LinkInfo]()
        for page in autoLinkPages {
            autoLinks.append(contentsOf: self.autoLinks(for: page, in: recognisedText.string))
        }

        var autoHotspots = [ImageHotspot]()

        let sortedLinks = autoLinks.sorted { $0.range.location < $1.range.location }
        var index = 0
        while (index < sortedLinks.count) {
            let scratchPad = self.createScratchPad(from: sortedLinks, currentIndex: &index)
            self.validateAutoLinks(in: scratchPad)
            for linkInfo in scratchPad.links {
                guard
                    linkInfo.state == .accepted,
                    let range = Range(linkInfo.range, in: recognisedText.string),
                    let boundingBox = recognisedText.normalisedBoundingBox(for: range, imageSize: imageSize, orientation: orientation)?.flipped(in: imageSize.toRect())
                else {
                    continue
                }
                let link = linkInfo.page?.linkToPage(autoGenerated: true)
                autoHotspots.append(ImageHotspot(kind: .rectangle, points: boundingBox.boundingPoints, link: link?.url))
            }
        }
        return autoHotspots
    }
}

extension ImageHotspot {
    var isAutoHotspot: Bool {
        guard
            let url = self.link,
            url.scheme == GlobalConstants.urlScheme,
            let link = PageLink(url: url)
        else {
            return false
        }

        return link.autoGenerated
    }
}

extension VNRecognizedText {
    func normalisedBoundingBox(for range: Range<String.Index>, imageSize: CGSize, orientation: CGImagePropertyOrientation) -> CGRect? {
        let width = imageSize.width
        let height = imageSize.height

        guard var boundingBox = try? self.boundingBox(for: range)?.boundingBox else {
            return nil
        }

        //We can tell the Vision framework what orientation the image is in, but it's not nice enough to actually rotate the results for us
        switch orientation {
        case .down:
            boundingBox = boundingBox.rotate(byRadians: Double.pi, around: CGPoint(x: 0.5, y: 0.5))
        case .left:
            boundingBox = boundingBox.rotate(byRadians: -Double.pi / 2, around: CGPoint(x: 0.5, y: 0.5))
        case .right:
            boundingBox = boundingBox.rotate(byRadians: Double.pi / 2, around: CGPoint(x: 0.5, y: 0.5))
        default:
            break
        }

        return CGRect(x: boundingBox.minX * width, y: boundingBox.minY * height, width: boundingBox.width * width, height: boundingBox.height * height)
    }
}
