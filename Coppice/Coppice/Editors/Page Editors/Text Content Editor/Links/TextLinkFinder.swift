//
//  TextLinkFinder.swift
//  Coppice
//
//  Created by Martin Pilkington on 06/12/2019.
//  Copyright Â© 2019 M Cubed Software. All rights reserved.
//

import Cocoa
import CoppiceCore

class TextLinkFinder: LinkFinder {
    static func findLinkChanges(in attributedString: NSAttributedString, using pages: [Page], ignoring ignoredPages: [Page] = []) -> LinkChanges {
        let existingLinks = self.existingLinks(in: attributedString, pages: pages, ignoredPages: ignoredPages)
        let autoLinkPages = self.autoLinkCandidates(from: pages, ignoring: ignoredPages)
        var autoLinks = [LinkInfo]()
        for page in autoLinkPages {
            autoLinks.append(contentsOf: self.autoLinks(for: page, in: attributedString.string))
        }

        let links = self.combineAndSort(existingLinks: existingLinks, autoLinks: autoLinks)
        var linkToAdd = [Link]()
        var linkToRemove = [Link]()
        var index = 0
        while (index < links.count) {
            let scratchPad = self.createScratchPad(from: links, currentIndex: &index)
            self.validateExternalLinks(in: scratchPad)
            self.validateManualLinks(in: scratchPad)
            self.validateAutoLinks(in: scratchPad)
            for linkInfo in scratchPad.links {
                //We want to add any valid new links
                if (linkInfo.age == .new) && (linkInfo.state == .accepted) {
                    let url = linkInfo.page?.linkToPage(autoGenerated: (linkInfo.linkType == .auto)).url
                    let link = Link(range: linkInfo.range, url: url)
                    linkToAdd.append(link)
                }
                //We want to remove any invalid existing links
                if (linkInfo.age == .existing) && (linkInfo.state == .rejected) {
                    let link = Link(range: linkInfo.range, url: nil)
                    linkToRemove.append(link)
                }
                //All other links can be discarded
            }
        }

        return LinkChanges(linksToRemove: linkToRemove, linksToAdd: linkToAdd)
    }

    /// Find all existing links inside the string
    private static func existingLinks(in attributedString: NSAttributedString, pages: [Page], ignoredPages: [Page]) -> [LinkInfo] {
        let pagesByID = pages.indexed(by: \.id)

        var links = [LinkInfo]()
        attributedString.enumerateAttribute(.link, in: attributedString.fullRange, options: []) { (value, range, _) in
            guard let value = value else {
                return
            }
            var page: Page? = nil
            var type: LinkInfo.LinkType = .external
            if let url = value as? URL,
               url.scheme == GlobalConstants.urlScheme,
               let link = PageLink(url: url)
            {
                    page = pagesByID[link.destination]
                    type = link.autoGenerated ? .auto : .manual
            }
            let linkInfo = LinkInfo(range: range, page: page, linkType: type, age: .existing)
            //If we have an existing auto link for an ignored page then we can immediately reject it
            if type == .auto, let page = page, ignoredPages.contains(page) {
                linkInfo.state = .rejected
            }
            links.append(linkInfo)
        }
        return links
    }

    private static func combineAndSort(existingLinks: [LinkInfo], autoLinks: [LinkInfo]) -> [LinkInfo] {
        let links = existingLinks + autoLinks
        return links.sorted { $0.range.location < $1.range.location }
    }

    //Rules
    private static func validateManualLinks(in scratchPad: LinkScratchPad) {
        let manualLinks = scratchPad.links.filter { $0.linkType == .manual && $0.state != .rejected }
        let autoLinks = scratchPad.links.filter { $0.linkType == .auto }

        for link in autoLinks {
            for manualLink in manualLinks {
                if link.range.intersection(manualLink.range) != nil {
                    link.state = .rejected
                    break
                }
            }
        }
    }

    private static func validateExternalLinks(in scratchPad: LinkScratchPad) {
        let externalLinks = scratchPad.links.filter { $0.linkType == .external && $0.state != .rejected }
        let autoLinks = scratchPad.links.filter { $0.linkType == .auto }

        for link in autoLinks {
            for manualLink in externalLinks {
                if link.range.intersection(manualLink.range) != nil {
                    link.state = .rejected
                    break
                }
            }
        }
    }

    struct LinkChanges {
        let linksToRemove: [Link]
        let linksToAdd: [Link]
    }

    struct Link: Equatable {
        let range: NSRange
        let url: URL?
    }
}
